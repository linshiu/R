customer = runif(100)*1000
length(customer)
sapply(price,function(x) customer>=x)
length(colSums(sapply(price,function(x) customer>=x))
length(colSums(sapply(price,function(x) customer>=x))
)
x=sapply(colSums(sapply(price,function(x) customer>=x)),
function(x) min(x,capacity))
length(x)
nCustomers
customer
price
length(price)
x=sapply(price,function(x) customer>=x)
length(x)
sapply(price,function(x) customer>=x)
customer
length(customer)
price
length(price)
customer>2
sapply(price,function(x) customer>=x)
x=sapply(price,function(x) customer>=x)
x[1]
View(x)
dim(x)
View(x)
colnames(x)
x[,"1000"]
colSums(sapply(price,function(x) customer>=x))
sapply(colSums(sapply(price,function(x) customer>=x)),
function(x) min(x,capacity))
x=sapply(colSums(sapply(price,function(x) customer>=x)),
function(x) min(x,capacity))
dim(x)
x
length(x)
nCustomers
length(nCustomers)
nCustomers = rep(0,length(price))
length(nCustomers)
nCustomers=rbind(nCustomers,
sapply(colSums(sapply(price,function(x) customer>=x)),
function(x) min(x,capacity)))
nCustomers
View(nCustomers)
nCustomers[1]
ronames(nCustomers)
rownames(nCustomers)
price*colMeans(nCustomers)
nCustomers[-1,]
price*colMeans(nCustomers[-1,])
n = 10 # simulation runs
capacity = 15
price = seq(0,1000,1)
names(price)=as.character(price)
nCustomers = rep(0,length(price))
for (i in 1:n){
# random customer's maximum price willig to pay
customer = runif(100)*1000
# for each price, sum the number of customer exceeding price and get the min of that
# and capacity
nCustomers=rbind(nCustomers,
sapply(colSums(sapply(price,function(x) customer>=x)),
function(x) min(x,capacity)))
}
# multiple # customers by price to get revenue
revenue = as.matrix(price*colMeans(nCustomers[-1,]))
colnames(revenue)= "Revenue"
names(price)[which(max(revenue)==revenue)]
max(revenue)
plot(price,revenue, pch=16)
colnames
revenue
n = 100 # simulation runs
capacity = 15
price = seq(800,900,1)
names(price)=as.character(price)
nCustomers = rep(0,length(price))
for (i in 1:n){
# random customer's maximum price willig to pay
customer = runif(100)*1000
# for each price, sum the number of customer exceeding price and get the min of that
# and capacity
nCustomers=rbind(nCustomers,
sapply(colSums(sapply(price,function(x) customer>=x)),
function(x) min(x,capacity)))
}
# multiple # customers by price to get revenue for each price
revenue = as.matrix(price*colMeans(nCustomers[-1,]))
colnames(revenue)= "Revenue"
# find the price with max revenue
names(price)[which(max(revenue)==revenue)]
max(revenue)
plot(price,revenue, pch=16)
n = 1000 # simulation runs
capacity = 15
price = seq(800,900,1)
names(price)=as.character(price)
nCustomers = rep(0,length(price))
for (i in 1:n){
# random customer's maximum price willig to pay
customer = runif(100)*1000
# for each price, sum the number of customer exceeding price and get the min of that
# and capacity
nCustomers=rbind(nCustomers,
sapply(colSums(sapply(price,function(x) customer>=x)),
function(x) min(x,capacity)))
}
# multiple # customers by price to get revenue for each price
revenue = as.matrix(price*colMeans(nCustomers[-1,]))
colnames(revenue)= "Revenue"
# find the price with max revenue
names(price)[which(max(revenue)==revenue)]
max(revenue)
plot(price,revenue, pch=16)
n = 1000 # simulation runs
capacity = 15
price = seq(800,900,1)
names(price)=as.character(price)
nCustomers = rep(0,length(price))
for (i in 1:n){
# random customer's maximum price willig to pay
customer = runif(100)*1000
# for each price, sum the number of customer exceeding price and get the min of that
# and capacity
nCustomers=rbind(nCustomers,
sapply(colSums(sapply(price,function(x) customer>=x)),
function(x) min(x,capacity)))
}
# multiple # customers by price to get revenue for each price
revenue = as.matrix(price*colMeans(nCustomers[-1,]))
colnames(revenue)= "Revenue"
# find the price with max revenue
names(price)[which(max(revenue)==revenue)]
max(revenue)
plot(price,revenue, pch=16)
nCustomers
View(nCustomer)
View(nCustomers)
# Part b ####
n = 1000 # simulation runs
capacity = 15
price = seq(800,825,1)
names(price)=as.character(price)
nCustomers = rep(0,length(price))
for (i in 1:n){
# random customer's maximum price willig to pay
customer = runif(100)*1000
# for each price, sum the number of customer exceeding price and get the min of that
# and capacity
nCustomers=rbind(nCustomers,
sapply(colSums(sapply(price,function(x) customer>=x)),
function(x) min(x,capacity)))
}
# multiple # customers by price to get revenue for each price
revenue = as.matrix(price*colMeans(nCustomers[-1,]))
colnames(revenue)= "Revenue"
# find the price with max revenue
names(price)[which(max(revenue)==revenue)]
max(revenue)
plot(price,revenue, pch=16)
# Part b ####
n = 1000 # simulation runs
n = 1000 # simulation runs
capacity = 15
price = seq(800,825,1)
names(price)=as.character(price)
nCustomers = rep(0,length(price))
for (i in 1:n){
# random customer's maximum price willig to pay
customer = runif(100)*1000
# for each price, sum the number of customer exceeding price and get the min of that
# and capacity
nCustomers=rbind(nCustomers,
sapply(colSums(sapply(price,function(x) customer>=x)),
function(x) min(x,capacity)))
}
# multiple # customers by price to get revenue for each price
revenue = as.matrix(price*colMeans(nCustomers[-1,]))
colnames(revenue)= "Revenue"
# find the price with max revenue
names(price)[which(max(revenue)==revenue)]
max(revenue)
plot(price,revenue, pch=16)
n = 1000 # simulation runs
capacity = 15
price = seq(800,825,1)
names(price)=as.character(price)
nCustomers = rep(0,length(price))
for (i in 1:n){
# random customer's maximum price willig to pay
customer = runif(100)*1000
# for each price, sum the number of customer exceeding price and get the min of that
# and capacity
nCustomers=rbind(nCustomers,
sapply(colSums(sapply(price,function(x) customer>=x)),
function(x) min(x,capacity)))
}
# multiple # customers by price to get revenue for each price
revenue = as.matrix(price*colMeans(nCustomers[-1,]))
colnames(revenue)= "Revenue"
# find the price with max revenue
names(price)[which(max(revenue)==revenue)]
max(revenue)
plot(price,revenue, pch=16)
n = 1000 # simulation runs
capacity = 15
price = seq(800,825,1)
names(price)=as.character(price)
nCustomers = rep(0,length(price))
for (i in 1:n){
# random customer's maximum price willig to pay
customer = runif(100)*1000
# for each price, sum the number of customer exceeding price and get the min of that
# and capacity
nCustomers=rbind(nCustomers,
sapply(colSums(sapply(price,function(x) customer>=x)),
function(x) min(x,capacity)))
}
# multiple # customers by price to get revenue for each price
revenue = as.matrix(price*colMeans(nCustomers[-1,]))
colnames(revenue)= "Revenue"
# find the price with max revenue
names(price)[which(max(revenue)==revenue)]
max(revenue)
plot(price,revenue, pch=16)
n = 1000 # simulation runs
capacity = 15
price = seq(800,825,1)
names(price)=as.character(price)
nCustomers = rep(0,length(price))
for (i in 1:n){
# random customer's maximum price willig to pay
customer = runif(100)*1000
# for each price, sum the number of customer exceeding price and get the min of that
# and capacity
nCustomers=rbind(nCustomers,
sapply(colSums(sapply(price,function(x) customer>=x)),
function(x) min(x,capacity)))
}
# multiple # customers by price to get revenue for each price
revenue = as.matrix(price*colMeans(nCustomers[-1,]))
colnames(revenue)= "Revenue"
# find the price with max revenue
names(price)[which(max(revenue)==revenue)]
max(revenue)
plot(price,revenue, pch=16)
library(rJava)
library(rJava)
4/110
48/55
37/41
x = list()
x
x[1]=c("a","b")
x[[1]]=c("a","b")
x
x[[1]][1]
a1 = c(1, 2, 3, 4, 5)
a2 = c(6, 7, 8, 9, 10)
a3 = c(11, 12, 13, 14, 15)
aframe = data.frame(a1, a2, a3)
aframe
aframe[,1]
aframe[,"a1"]
aframe$a1
class(aframe[,1])
class(aframe[,"a1"])
class(aframe$a1)
aframe[["a1"]]
class(aframe[["a1"]])
aframe[[1]]
aframe[[1,1]]
aframe[[1,2]]
aframe[1,2]
x[1]
x
x[[1]]
x[1]
class(x[[1]])
class(x[1])
x[[2]]=c(1,2,3)
x
x[[2]]
class(x[[2]])
x[2]
class(x[2])
x[[3]]=2
x
P = cbind(c(.4,.2,.1),c(.6,0,0),c(0,.8,.9))
P
n = matrix(c(1000,0,0))
n
v = matrix(c(90,-10,-10))
v
t(n) %*% P
t(n) %*% P %*% P
t(n) %8% P %*% V
t(n) %*% P %*% V
t(n) %*% P %*% v
t(n) %*% P %*% P %*% v
t(n) %*% solve(diag(3)-P/1.2) %*% v
# My PC
main = "C:/Users/Steven/Documents/Academics/3_Graduate School/2014-2015 ~ NU/"
# Aginity
#main = "\\\\nas1/labuser169"
course = "MSIA_420_Predictive_Analytics"
datafolder = "Data"
setwd(file.path(main,course, datafolder))
#### MA filtering/prediction for chem.csv ####
chem=read.csv("chem.csv",header=F)
y=ts(chem[[1]], frequency=1)
m=20;k=20;n=length(y)  #m = MA window length, k = prediction horizon
plot(y,type="b",xlim=c(0,n+k))
MAchem=filter(y, filter=rep(1/m,m), method = "convolution", sides = 1)
yhat=c(NA,MAchem,rep(MAchem[n],k-1))  #fits and forecasts
lines(yhat,col="red")
?ts
?filter
plot(y,type="b",xlim=c(0,n+k))
yhat=c(NA,MAchem,rep(MAchem[n],k-1))  #fits and forecasts
yhat
MAchem
length(yhat)
197+20
y=ts(chem[[1]], frequency=1)
alpha=0.2;k=20;n=length(y)  #m = MA window length, k = prediction horizon
plot(y,type="b",xlim=c(0,n+k))
EWMAchem=alpha*filter(y, filter=1-alpha, method = "recursive",
sides = 1, init=y[1]/alpha)
yhat=c(NA,EWMAchem,rep(EWMAchem[n],k-1))
lines(yhat,col="red")
y=ts(chem[[1]], frequency=1)
alpha=0.9;k=20;n=length(y)  #m = MA window length, k = prediction horizon
plot(y,type="b",xlim=c(0,n+k))
EWMAchem=alpha*filter(y, filter=1-alpha, method = "recursive",
sides = 1, init=y[1]/alpha)
yhat=c(NA,EWMAchem,rep(EWMAchem[n],k-1))
lines(yhat,col="red")
y=ts(chem[[1]], frequency=1)
alpha=0.01;k=20;n=length(y)  #m = MA window length, k = prediction horizon
plot(y,type="b",xlim=c(0,n+k))
EWMAchem=alpha*filter(y, filter=1-alpha, method = "recursive",
sides = 1, init=y[1]/alpha)
yhat=c(NA,EWMAchem,rep(EWMAchem[n],k-1))
lines(yhat,col="red")
y=ts(chem[[1]], frequency=1)
alpha=0.2;k=20;n=length(y)  #m = MA window length, k = prediction horizon
plot(y,type="b",xlim=c(0,n+k))
EWMAchem=alpha*filter(y, filter=1-alpha, method = "recursive",
sides = 1, init=y[1]/alpha)
yhat=c(NA,EWMAchem,rep(EWMAchem[n],k-1))
lines(yhat,col="red")
y=ts(chem[[1]], frequency=1)
k=20;n=length(y)  #k = prediction horizon
EWMAchem=HoltWinters(y, seasonal = "additive", beta = FALSE, gamma = FALSE)
EWMAchemPred=predict(EWMAchem, n.ahead=k, prediction.interval = T, level = 0.95)
plot(EWMAchem,EWMAchemPred,type="b")
EWMAchem
?HoltWinters
trade=read.csv("trade.csv",header=F)
y=ts(trade[[1]], deltat=1)  #sampling interval corresponds to 1/12 the seasonality period
EWMAtrade=HoltWinters(y, seasonal = "additive", beta = FALSE, gamma = FALSE)
EWMAtradePred=predict(EWMAtrade,
n.ahead=12, prediction.interval = T, level = 0.95)
plot(EWMAtrade,EWMAtradePred,type="b")
EWMAtrade
par(mfrow=c(2,1))
y = ts(chem[[1]], frequency=1)
m=20;n=length(y)
MAchem = filter(y, filter=rep(1/m,m), method = "convolution", sides = 1)
plot(y,type="b",xlim=c(0,n))
lines(MAchem,col="red")
##noncentered MA
par(mfrow=c(2,1))
y = ts(chem[[1]], frequency=1)
m=20;n=length(y)
MAchem = filter(y, filter=rep(1/m,m), method = "convolution", sides = 1)
plot(y,type="b",xlim=c(0,n))
lines(MAchem,col="red")
##centered MA
y=ts(chem[[1]], frequency=1)
m=20;n=length(y)
MAchem=filter(y, filter=rep(1/m,m), method = "convolution", sides = 2)
plot(y,type="b",xlim=c(0,n))
lines(MAchem,col="red")
par(mfrow=c(1,1))
?filter
trade = read.csv("trade.csv",header=F)
y = ts(trade[[1]], deltat=1/12)  #sampling interval corresponds to 1/12 the seasonality period
m=12;n=length(y)
MAtrade = filter(y, filter=rep(1/m,m), method = "convolution", sides = 2)
plot(y,type="b")
lines(MAtrade,col="red")
trade = read.csv("trade.csv",header=F)
y = ts(trade[[1]], deltat=1/12)  #sampling interval corresponds to 1/12 the seasonality period
m=12;n=length(y)
MAtrade<-filter(y, filter=rep(1/m,m), method = "convolution", sides = 2)
plot(y,type="b")
lines(MAtrade,col="red")
##m = 10 for centered MA
trade = read.csv("trade.csv",header=F)
y = ts(trade[[1]], deltat=1/12)  #sampling interval corresponds to 1/12 the seasonality period
m=10;n=length(y)
MAtrade<-filter(y, filter=rep(1/m,m), method = "convolution", sides = 2)
plot(y,type="b")
lines(MAtrade,col="red")
y = ts(chem[[1]], frequency=1)
k=20;n=length(y)  #k = prediction horizon
Holtchem = HoltWinters(y, seasonal = "additive", gamma = FALSE)
HoltchemPred = predict(Holtchem, n.ahead=k,
prediction.interval = T, level = 0.95)
plot(Holtchem,HoltchemPred,type="b",ylim=c(16,18))
##repeat, but specifying alpha and larger beta
Holtchem = HoltWinters(y, seasonal = "additive",
alpha=.4, beta=.3,gamma = FALSE,
l.start=17, b.start=.03)
HoltchemPred = predict(Holtchem,
n.ahead=k, prediction.interval = T, level = 0.95)
plot(Holtchem,HoltchemPred,type="b",ylim=c(16,18))
Holtchem = HoltWinters(y, seasonal = "additive",
alpha=.4, beta=.05,gamma = FALSE,
l.start=17, b.start=.03)
HoltchemPred = predict(Holtchem, n.ahead=k,
prediction.interval = T, level = 0.95)
plot(Holtchem,HoltchemPred,type="b",ylim=c(16,18))
trade=-read.csv("trade.csv",header=F)
y = ts(trade[[1]], deltat=1/12)  #sampling interval corresponds to 1/12 the seasonality period
k=20;n=length(y)  #k = prediction horizon
EWMAtrade<-HoltWinters(y, seasonal = "additive", gamma = FALSE)
EWMAtradePred<-predict(EWMAtrade, n.ahead=k,
prediction.interval = T, level = 0.95)
plot(EWMAtrade,EWMAtradePred,type="b",ylim=c(300,450))
trade=-read.csv("trade.csv",header=F)
y = ts(trade[[1]], deltat=1/12)  #sampling interval corresponds to 1/12 the seasonality period
k=20;n=length(y)  #k = prediction horizon
EWMAtrade = HoltWinters(y, seasonal = "additive", gamma = FALSE)
EWMAtradePred = predict(EWMAtrade, n.ahead=k,
prediction.interval = T, level = 0.95)
plot(EWMAtrade,EWMAtradePred,type="b",ylim=c(300,450))
head(trade)
summary(trade)
trade=-read.csv("trade.csv",header=F)
y = ts(trade[[1]], deltat=1/12)  #sampling interval corresponds to 1/12 the seasonality period
k=20;n=length(y)  #k = prediction horizon
EWMAtrade = HoltWinters(y, seasonal = "additive", gamma = FALSE)
EWMAtradePred = predict(EWMAtrade, n.ahead=k,
prediction.interval = T, level = 0.95)
plot(EWMAtrade,EWMAtradePred,type="b",ylim=c(-300,-450))
EWMAtrade
Holtchem
y = ts(chem[[1]], frequency=1)
k=20;n=length(y)  #k = prediction horizon
Holtchem = HoltWinters(y, seasonal = "additive", gamma = FALSE)
HoltchemPred = predict(Holtchem, n.ahead=k,
prediction.interval = T, level = 0.95)
plot(Holtchem,HoltchemPred,type="b",ylim=c(16,18))
Holtchem
Holtchem
Holtchem = HoltWinters(y, seasonal = "additive",
alpha=.4, beta=.3,gamma = FALSE,
l.start=17, b.start=.03)
HoltchemPred = predict(Holtchem,
n.ahead=k, prediction.interval = T, level = 0.95)
plot(Holtchem,HoltchemPred,type="b",ylim=c(16,18))
HoltchemPred
Holtchem
Holtchem = HoltWinters(y, seasonal = "additive",
alpha=.4, beta=.05,gamma = FALSE,
l.start=17, b.start=.03)
HoltchemPred = predict(Holtchem, n.ahead=k,
prediction.interval = T, level = 0.95)
plot(Holtchem,HoltchemPred,type="b",ylim=c(16,18))
HoltchemPred
trade = read.csv("trade.csv",header=F)
y = ts(trade[[1]], deltat=1/12)  #sampling interval corresponds to 1/12 the seasonality period. Could instead specify frequency = 12
k=24;n=length(y)  #k = prediction horizon
HWtrade = HoltWinters(y, seasonal = "additive")
HWtradePred = predict(HWtrade, n.ahead=k, prediction.interval = T, level = 0.95)
plot(HWtrade,HWtradePred,type="b",ylim=c(300,450))
HWtrade
trade = read.csv("trade.csv",header=F)
y = ts(trade[[1]], deltat=1/12)  #sampling interval corresponds to 1/12 the seasonality period
k=24;n=length(y)  #k = prediction horizon
Dectrade = decompose(y, type = "additive")
plot(Dectrade,type="b")
Dectrade
y_hat = Dectrade$trend+Dectrade$seasonal
plot(y,type="b")
lines(y_hat,col="red")
Holtchem = HoltWinters(y, seasonal = "additive", gamma = FALSE)
Holtchem
plot(Holtchem,HoltchemPred,type="b",ylim=c(16,18))
##let algorithm find optimal alpha and beta
y = ts(chem[[1]], frequency=1)
k=20;n=length(y)  #k = prediction horizon
Holtchem = HoltWinters(y, seasonal = "additive", gamma = FALSE)
HoltchemPred = predict(Holtchem, n.ahead=k,
prediction.interval = T, level = 0.95)
plot(Holtchem,HoltchemPred,type="b",ylim=c(16,18))
Holtchem
HoltchemPred
Holtchem
##repeat, but specifying alpha and smaller beta
Holtchem = HoltWinters(y, seasonal = "additive",
alpha=.4, beta=.05,gamma = FALSE,
l.start=17, b.start=.03)
HoltchemPred = predict(Holtchem, n.ahead=k,
prediction.interval = T, level = 0.95)
plot(Holtchem,HoltchemPred,type="b",ylim=c(16,18))
Holtchem
